#If Statement
x=int(input("Choose number between 1 and 10: "))
if x<0 or x>10:
  print("invalid")
else:
  print("number within the range")

password=input("Enter your password: ")
if password == "password":
  print("Success")
else:
  print("Try Again!")

#For Loops 1 
country=['Canada','USA','Mexico','Australia']
for x in country:
  print('Country: ' + x)
print()

#For Loops 2
for i in range(1,101):
  print(i)
print()

#For Loops 3
num = 3
for i in range(3, 19):
  print(num*i)
print()

#For Loops 4
for i in range(1,11)[::-1]:
  print(i)
print()

#For Loops 5
for i in range(1,11):
  if i%2 == 0:
    print(i)
print()

#For Loops 6
sums=0
for i in range(99,201):
  sums += i
print(sums)
print()

#While Loops 1
country = ["Canada","USA","Mexico"]
i = 0
while i < len(country):
  print(country[i])
  i += 1
print()

#While Loops 2
#for loop iterates for specific number of times while while loop iterates as long as condition is true

#While Loops 3
#Yes

#While Loops 4
#Yes

#Functions 1
def sum_list(list):
  sum1=0
  for l in range(len(myList)):
    sum1 += (myList[l])
  print(sum1)
myList=[1,2,3,4,5]
sum_list(myList) 
print()
  
#Functions 2
#Yes

#Functions 3
#Yes

#Functions 4
#variables in a function can be used in another function only if they are returned

#Lists 1
states = ['Alabama', 'Wyoming', 'Montana', 'Michigan']
for s in range(len(states)):
  if states[s][0] == 'M':
    print(states[s])
print()

#List Operations 1
y=[6,4,2]
y.append(12)
y.append(8)
y.append(4)
print(y)
print()

#List Operations 2
y[1]=3
print(y)
print()

#Sorting List 1
x=[(3,6),(4,7),(5,9),(8,4),(3,1)]
x.sort()
print(x)
print()

#Sorting List 2
def secondElement(e):
  return e[1]
x=[(3,6),(4,7),(5,9),(8,4),(3,1)]
x.sort(key=secondElement)
print(x)
print()

#Range Function 1
x=list(range(1,1001))
print(x)
print()

#Range Function 2
x=list(range(1,1001))
print(min(x))
print(max(x))
print()

#Range Function 3
oddList=[]
evenList=[]
for i in range(len(x)):
  if x[i]%2==0:
    evenList.append(x[i])
  else:
    oddList.append(x[i])
print(oddList)
print(evenList)
print()

#Dictionary 1
country={}
country["Korea"]="KOR"
country["Japan"]="JPN"
country["United States of America"] = "USA"

#Dictionary 2
for i in country:
  print(i,country[i])
print()

#Read File 1
# filename = "file.py"
# with open(filename) as f:
#     content = f.readlines()
# print(content)

#Read File 2
#It'll throw an Exception

#Write File 1
#f.write('take it easy')
#Write File 2
#f.write("open(“text.txt”)")

#Nested Loops 1
for i in range(3):
  for j in range(3):
    print(i,j)
print()

#Nested Loops 2
persons = ["John", "Marissa", "Pete", "Dayton"]
for p in range(len(persons)):
  e=p
  while e<len(persons) -1:
    print(f"{persons[p]} meets {persons[e+1]}")
    e+=1
print()

#Nested Loops 3

#Slices 1
pizza = ["Hawaii", "Pepperoni", "Fromaggi", "Napolitana", "Diavoli"]
slice = pizza[2]
print(slice)
print()

#Slices 2
text = "Hello World"
slice = text[6:]
print(slice)
print()

#Multiple Return 1
def sum(a,b):
  return a+b
print(sum(3,19))
print()

#Multiple Return 2
def multipleReturn():
  name="Eunice"
  age=28
  country="USA"
  hobby="Watching Anime"
  food="Sushi"
  return name,age,country,hobby,food
name,age,country,hobby,food = multipleReturn()
print(name,age,country,hobby,food)
print()

#Scope 1,2
def reducebalance(balance):
  newbal = balance - 100
  return newbal
initialbalance = 1000
newbalance = reducebalance(initialbalance)
print()

#Time and Date
from datetime import date
today = date.today()
print("Today's date:", today)
print()

#Try Except
#1. Yes
#2. Yest
#3. When it throws an error instead Exception

#OOP EXERCISES
#Class
#1. Yes
#2. Yes
#3. No
#4
class Person:
  def getAge(self):
    return self._age

  def setAge(self, x):
    self._age=x
  
  def location(self):
    print("Seattle")
Eunice=Person()
print()

#Getter and Setter
#1. See code above
#2. Encapsulation-to regulate access of the object

#Modules 1
import math
print(math.sin(3))

#Modules 2
def snake():
  print("Huge Anaconda")

import main
main.snake()
print()

#Inheritance 1, 2
class App:
  def start(self):
    print('Parent Class')

class Iphone(App):
  def getVersion(self):
    print('Newest Version')

class Phone(App, Iphone):
  def getPhone(self):
    print('Phone in general')

#Static Method
#1. Yes
#2. Static methods have limited use, because they don't have access to the attributes of an instance of a class, and they don't have access to the attributes of the class itself. Its not the best option for long-term use.

#iterable
#1. An iteratable is a Python object that can be used as a sequence. You can go to the next item of the sequence using the next() method.
#2. Iterable object types includes lists, strings, dictionaries and sets.

#ClassMethod
#1. A class method is a method that’s shared among all objects. To call a class method, put the class as the first argument. Class methods can be can be called from instances and from the class itself. All of these use the same method. The method can use the classes variables and methods.
#2. Static method is not bound to any one class, while a class method is

#Multiple Inheritance
#1. No, Java doesn't 
#2. Multiple inheritance is prone to ambiguity
#3. No
